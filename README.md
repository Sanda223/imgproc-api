# AWS Image Processing Platform

A **cloud-native image processing system** built with **Node.js + Express + TypeScript**, fully containerised with **Docker** and deployed across **AWS ECS (Fargate)** using images hosted in **ECR**.  
The platform performed CPU-intensive image transformations (resize, blur, sharpen) using [Sharp](https://sharp.pixelplumbing.com/), scaling horizontally across containers to sustain **80%+ CPU load** under concurrent requests.

---

## Features

- **Microservice architecture** with isolated containers for the REST API and the image-processing worker  
- **Asynchronous job handling** with **SQS** queueing and **presigned S3 uploads**  
- **Secure authentication** using **AWS Cognito** (JWT-based)  
- **Autoscaling** via **ECS Service Auto Scaling** with CloudWatch metrics  
- **HTTPS** served through **Application Load Balancer (ALB)** and **ACM certificates**  
- **Infrastructure-as-Code (IaC)** using AWS CDK for consistent, repeatable deployments  
- **Monitoring and logging** integrated with **CloudWatch** dashboards and alerts  
- **CI/CD pipeline** via **GitHub Actions → ECR → ECS rollout**  
- **Edge caching** for static frontend assets with **CloudFront**  

---

## Architecture Overview

| Service | Role | AWS Components |
|----------|------|----------------|
| **API Service** | Handles authentication, job creation, and image retrieval | ECS (Fargate), ALB, Cognito, CloudWatch |
| **Worker Service** | Performs CPU-intensive Sharp image processing | ECS (Fargate), SQS, CloudWatch |
| **Storage Layer** | Persists uploaded and processed images | S3, DynamoDB |
| **Load Distribution** | Routes requests and balances traffic | ALB, SQS |
| **Monitoring & Scaling** | Tracks CPU metrics and triggers scale-in/out events | CloudWatch, Application Auto Scaling |
| **CI/CD Pipeline** | Automates container builds and deployments | GitHub Actions, ECR, ECS |
| **Security & Access** | Manages authentication and HTTPS | Cognito, ACM, Route 53 |
| **Edge Caching** | Serves cached static assets globally | CloudFront |

---

## AWS Deployment Summary

1. **Dockerised** both API and worker services independently  
2. **Published images** to **AWS Elastic Container Registry (ECR)**  
3. **Deployed containers** on **AWS ECS (Fargate)** using ECS services and task definitions  
4. **Configured Application Load Balancer (ALB)** for HTTPS and routing rules  
5. **Implemented autoscaling** based on CloudWatch metrics (CPU > 70%)  
6. **Used SQS** to distribute workload evenly among worker containers  
7. **Enabled CloudWatch logging** for real-time observability and error tracking  
8. **Provisioned all infrastructure via AWS CDK**, enabling one-click redeployment  

---

## Workflow Overview

1. **User uploads an image** via presigned S3 URL  
2. **API service** creates a new job record in DynamoDB and queues the task in SQS  
3. **Worker service** fetches messages from SQS, processes the image with Sharp, and stores the result in S3  
4. **Job metadata** is updated in DynamoDB with the processed image URL  
5. **User retrieves** the result through a signed URL generated by the API  

---

## Core AWS Services

- **ECS (Fargate)** – container orchestration and autoscaling  
- **ECR** – private container image registry  
- **S3** – object storage for uploads and outputs  
- **SQS** – distributed job queue for worker containers  
- **DynamoDB** – metadata persistence  
- **Cognito** – authentication and JWT token management  
- **CloudWatch** – metrics, logging, autoscaling triggers  
- **ALB + ACM** – HTTPS routing with SSL certificates  
- **CloudFront** – edge caching for global static asset delivery  
- **CDK (IaC)** – automated provisioning and teardown  
- **GitHub Actions** – CI/CD automation  

---

## Technical Highlights

- Designed **fault-tolerant horizontal scaling** for CPU-bound workloads  
- Deployed **multi-container ECS architecture** with isolated scaling policies per service  
- Implemented **secure presigned S3 uploads** and verified object integrity pre-processing  
- Built **CI/CD workflow** for automatic container build, push, and ECS redeployment  
- Integrated **CloudWatch alarms** and dashboards for autoscaling and latency metrics  
- Optimised worker CPU utilisation to achieve >80% sustained usage under load test  
- Configured **HTTPS** with ALB routing and ACM-issued TLS certificates  

---

## Performance Demonstration

- Load tests simulated **20+ concurrent users** and **hundreds of queued jobs**  
- ECS autoscaling expanded worker service from **1 → 3 containers** within 30 seconds under load  
- CloudWatch metrics confirmed balanced distribution via SQS and stable API latency  
- All scaling, processing, and retrieval operations maintained zero downtime  

---

## Infrastructure-as-Code Example (CDK)

```ts
const apiService = new ecs.FargateService(this, 'ApiService', {
  cluster,
  taskDefinition: apiTask,
  desiredCount: 1,
  assignPublicIp: true,
  loadBalancers: [alb],
});

const workerService = new ecs.FargateService(this, 'WorkerService', {
  cluster,
  taskDefinition: workerTask,
  desiredCount: 1,
  assignPublicIp: true,
});

workerService.autoScaleTaskCount({ minCapacity: 1, maxCapacity: 3 })
  .scaleOnCpuUtilization('CpuScaling', {
    targetUtilizationPercent: 70,
    policyName: 'WorkerCpuScaling',
  });
```

---

## Cost Estimate (50 Concurrent Users)

| Component | Service | Monthly Cost (approx.) |
|------------|----------|------------------------|
| API + Worker Containers | ECS Fargate | \$25 |
| Storage | S3 | \$2 |
| Database | DynamoDB | \$3 |
| Messaging | SQS | \$1 |
| Monitoring | CloudWatch | \$2 |
| Edge Delivery | CloudFront | \$1 |
| **Total Estimate** |  | **≈ \$34/month** |

---

## License  
For educational and demonstration purposes only.  
© 2025 Sandaru Nakandage
